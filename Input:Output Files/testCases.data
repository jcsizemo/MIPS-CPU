@00 8C	 //1000 1100	    //LW $2, 0xA0($0)
@01 02	 //0000 0010	    // 1000 1100 0000 0010 0000 0000 0100 0111
@02 00   //0000 0000
@03 A0   //1010 0000

@04 8C	 //1000 1100	    //LW $3, 0xA4($0)
@05 03	 //0000 0011	    // 1000 1100 0000 0010 0000 0000 0100 0111
@06 00   //0000 0000
@07 A4   //1010 0100

@08 8C	 //1000 1100	    //LW $4, 0xCC($0)
@09 04	 //0000 0100	    // 1000 1100 0000 0010 0000 0000 0100 0111
@0A 00   //0000 0000
@0B CC   //1100 1100

@0C 8C	 //1000 1100	    //LW $5, 0xD0($0)
@0D 05	 //0000 0101	    // 1000 1100 0000 0010 0000 0000 0100 0111
@0E 00   //0000 0000
@0F D0   //1101 0000
			
@10 80	 //1000 0000	// LB $7, 0x05($2) : MEM[ R2 + 0x05] = R7	// load ahead, 7F to test sign extend
@11 47   //0100 0111	// 100000 00010 00111 0000000000000101 
@12 00   //0000 0000	// opcode  src   dest   offset
@13 05   //0000 0101

@14 80	 //1000 0000	// LB $8, 0xFFF6($3) : MEM[ R3 + 0xFFF6] = R8	// load backwards, 80 to test sign extend
@15 68   //0110 1000	
@16 FF   //1111 1111 	
@17 F6   //1111 0110

@18 80	 //1000 0000	// LB $9, 0x05($0) : MEM[ R0 + 0x05] = R9	// load byte from a previous instruction to be used
@19 09   //0000 1001							// in the next instruction to load another byte
@1A 00   //0000 0000	
@1B 05   //0000 0101

@1C 81	 //1000 0001	// LB $10, 0x00FB($9) : MEM[ R9 + 0x00FB] = R10     // compute big offset using sign-extended byte
@1D 2A   //0010 1010							    // from previous address as base address
@1E 00   //0000 0000	
@1F FB   //1111 1011	

@20 80	 //1000 0000	// LB $11, 0xA715($5) : MEM[R5 + 0xA715] = R1	    // base address far away in memory, go backwards
@21 AB	 //1010 1011							    // with a big offset
@22 A7	 //1010 0111
@23 15	 //0001 0101

@24 AC   //1010 1100	    //SW $7, 0X50($0) : MEM[ 0X50+R0 ] = R7		// store the bytes starting with location 0x50
@25 07   //0000 0111								// ending at location 0x60
@26 00   //0000 0000
@27 50   //0101 0000 

@28 AC   //1010 1100	    //SW $8, 0X54($0) : MEM[ 0X54+R0 ] = R8
@29 08   //0000 1000
@2A 00   //0000 0000
@2B 54   //0101 0100 

@2C AC   //1010 1100	    //SW $9, 0X58($0) : MEM[ 0X58+R0 ] = R9
@2D 09   //0000 1001
@2E 00   //0000 0000
@2F 58   //0101 1000 

@30 AC   //1010 1100	    //SW $10, 0X5C($0) : MEM[ 0X5C+R0 ] = R10
@31 0A   //0000 1010
@32 00   //0000 0000
@33 5C   //0101 1100 

@34 AC   //1010 1100	    //SW $11, 0X60($0) : MEM[ 0X60+R0 ] = R11
@35 0B   //0000 1011
@36 00   //0000 0000
@37 60   //0110 0000 
									   
@38 FF   //1111 1111       //BREAK
@39 00   //0000 0000
@3A 00   //0000 0000
@3B 0D   //0000 1101

@A0 00   // input data
@A1 00
@A2 00
@A3 A3

@A4 00
@A5 00
@A6 00
@A7 B3

@A8 7F 
@A9 80
@AA CD
@AB AB

@AC 00
@AD 11
@AE 22
@AF 33

@CC 00
@CD 00			
@CE 59
@CF DA

@D0 00
@D1 00
@D2 59
@D3 EA

@D4 7F
@D5 86
@D6 80
@D7 69

@FC AA
@FD 71
@FE BE
@FF EF





